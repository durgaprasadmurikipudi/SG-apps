'React' knows all about component and how to make components work together.
'React-Dom' knows how to take a component and show up it in the DOM.

Create-react-app installs webpack, babel, devserver.
Babel is used to compile versions of javascript that belongs to ES2015  to ES2019 into ES5 version.
ES5 is  supported by almost all browsers.
ES2015 has greater support, but still there are exceptions.
But from ES2016 till ES2019, there is no support yet.
Babel spits out ES5version code.

Babel also converts JSX.

JSX is a simple extension to Javascript that looks like a templating language and allows us to define the UI structure
in the component in familiar HTML syntax.

JSX vs HTML, there are 3 differences that we have to take care while we write JSX.
Although JSX share many similarities with HTML,
1. Style is defined as an object rather than as an attribute, ex: <div style={{backgroundColor: 'red';}}/>
   Also, background-color is how CSS refers it, but in React, how it has changed like backgroundColor, the hyphen is removed and
   letter after that is capitalized. Now if a css property is there like.. border: 1px solid red; => { border: '1px solid red';}
   The values ofcourse would be value JS types belonging to number or string, array can also be used, but it will converted into 
   value equal to its toString representation.
2. JSX used 'className' instead of class unlike HTML to denote a application of a css class. ex: <div className='cool'/>
    and htmlFor for 'for' in case of Label tags.
3. JSX actually can refer variables inside it. Do little bit of Javascript and generate more JSX inside it.
    like if there is a loop inside a JSX that actually returns JSX, that will evaluated.
    ex: { <ul>{ items.map(item => <li>item.value</li>) } </ul>}.
    Here, inside JSX, list of 'li' items will be produced whose count will be equal to items.length.
4. There is very little much of things that JSX can display, a valid JSX will be turned to equivalent HTML and will
   be displayed, and just a string( Array as toString) or number can also be considered as valid JSX that could be displayed.
   If you try to print or display object, it will say its not a valid child of React. OR not a valid React Children.
   Although you can refer any valid JS type. And can actually embed any expression in JSX, 
   the expression will be evalauted and its result will be shown.

Components:
3 Tenets of components:
Component Nesting: A component can be shown inside of another.
Component Reusability: We want to make components that can be easily reused through out our application.
Component Configuration: We should be able to configure a component when it is created.

Miniature Comment app:
So if we build a comment app that generates comments,
Its obviously essentail to build the comment component out of the main component that hosts it, so that there is clear logic 
seperation.
Now we can host the comment app inside APP - container component. This gives two things,
component nesting and component reuse.
We can decalare multiple comment instances inside app component for to all the comments thats we see.

So you declare a comment componet code in separate file, but you need to declare required packages again here.
Like react etc,

Regrading comment configuration, props comes into picture.
Props system is what we use to distinguish one componen system from another.
Becuase obviously every comment has a same structure but different content. Props system is how we send the component specific data.

Here app component hosts comment-detail component.
The parent component is responsible for passing props down to child. Effectively controlling the content of each component
instnace and also so much as to customize the behaviour of each component like behavior of component w.r.t to user interaction etc..

So how do you pass this props ?
There is no magic, while we declare the component that we want in JSX, we also pass some the data we want as key value pairs 
inside the component tag. ex:
<ComponentName key1:"data" key2:{object1.prop1.someData} />

If the component is a functional component, it will recieve a param object conventionally called params,
which has all this key value pairs as object properties.
We can then access it inside the component by just referring the name.
We can pass as props any valid js types including functions.

Not satisfied with the component reuse functionality and componet composition example.
Lets think of a approval card example.
An approval card in a typical blog platform for a comment would be like the one where it asks the blog author to approve a comment
provided by netizens.
Here approval card is just a basic ui card, typially we can wrap the comment component in this approval card and ask them to
approve the componetn and also, we can provide some text i nthe same approval card to confirm some action that they are performing.
See, we used comment component inside a approval card component, component composition and component resuability.
Because we use that comment component to display as well as for as approval as well.
Composing thus provides a way to build component which are sophisticated out of simple components.

Now we have to learn props.children property.
Here we can pass componet as one of key value paors in props, or we can wrap the component in the opening and closing tags 
of the parent component.
like below:
<Parent><children/></Parent>

Now in the parent component, it is available as props.children, pass whatever in the opening and closing tags of a component, it will 
be available as props.children!

So there you go a great example for component reuse and component composition.

A component is anything that generates HTML and reacts to user events and accodingly gives response.

So far, we have seen functional components, lets talk about class components.
A functional component is used to display simple content and a class component is used for anything else.

A class component while allowing you ti give a sense of organized code, it also gives access to state and lifecycle methods
to control component manoeuver through out its birth till death.

To give an example where class component shines: 
Imagine where we are locating a clients location by using geolocation api, then based on its result, we want to display its 
location.

In functional component, JSX is displayed as and when its prepared, how do you display it again after the result from api returns?
If you delay the return call till location api returns results then user is gonna wait.. right ?

Class component allows you to display some content while our api is fetching the lcoation like a spinner and then re-display the 
content once api result comes up!

So this done by with the help of state system:
A state is a traditional JS object taht contains the data relevant to the component instance.
Updating state always re renders the component. ( mostly instantly)
State must always be initialised before usage.
State must always be updated with setState function.

State lifecycle walk through:
Now that we have established the basic rules how are we gonna achive the solution to above problem.

We initialise the state in constructor with lat property as null, in constructor.
And also with the error propety to show the error message if anything goes wrong.

this.state = {lat:null, err: null}.

We make call to geolocationapi in constructor function, we set the lat property in success call back.
We set the error property incase of an error.
Now we refer the latitiude in render function via state.
Initially nothing is displayed, but when the api results are out, if its success, success call back updates the lat property,
this triggering the re-render and hence lat is displayed.
else the error property is displayed.

WE can conditionally render either of this depending on the state value.
This is how we achieve the solution.

Lifecycle methods line by line - by order:
constructor function is called when the component instance is created.
render method is called to display JSX.
componentDidMount is called as soon as the component instance is mounted on the DOM.

Whever the state chanegd or props changed..
render method will be again called.
componentDidUpdate method will be called right after component is mounted on DOM with updated data.

Once when the time comes when component has to be removed from the DOM, then componentWillUnmount will be called.

Its a react recommendation and a genral best practice to put the network calls inside the componentDidUpdate.
Although there will be 2 renders, react will quickly construct the new DOM in no time!

To provide a default params : syntax would be..

component.defaultProps = {
    ... all the props param defaults.
}

Mind it...always when event handler is passed to an event in the form, only reference is passed.
It's basically like the copy of function is being passed and so by default no instance of 'this' will be set.

Also, in controlled components, React owns the data rather than DOM.
Beucase when we display an input field and type some data into it, DOM actually stores the data.
In case of a controlled component, React owns it and without ever digging into DOM, it owns the data flow of App.

Basically in the form field when you press enter on any input, it actually submits the form!!!
remember this, so that you will call event.preventDefault() onSubmit event.
Also, after on sumbit all input fields get reset, so its important to know this.

Always and always remember when you use value props, always include a handler function for onChange or else you are 
essentially displaying a read-only field.

The interesting thing about how event handler functions declared in class do not have access to this.state or this.props 
or for that matter 'this' itself, is it can be fixed by not only binding 'this' to that function in the constructor 
but also by making the event handler an arrow function, but also...

Call the normal event handler function in the context of arrow function, yes that fixes it!

like just (event) => call_to_normal_Event_handler_non_arrow_function(event)
The above expession works and the normal event handler function with this can again have access to this that points to the instance of 
component.

The props system is not only desinged to configure the child components, but also a way to communicate with parents from the 
children side. Generally it is done via callbacks being passed down as props to the child components and the child components
generally call those funcions with the data the child wants to send back to the parent.
Wheever props changes, componetn will rerender, componentDidUpdate gets triggered for sure.

One interesting and very important thing to remember is that, when we send a function as props to some other component,
then it results back with some data by calling that function.
Here in this function, which we sent as props, if we call this.setState, it would not work!!!, reason, the function was 
send as a reference rather than any. Hence the function now which is part of props object,
will have its this property set to the props object and hence no access to this.setState obviously.

So we always bind our event handlers by default in constructor. Now you know the reason.
Also, if event handler is an arror function or while passing to props if its sent in the context of arrow function call
this issue would not arise.
ex: for in context of arrow function: <SearchBar onSubmit={(term) => this.handleSearch(term)} />
The arrow function wraps the this as parent component instance and so in effect, the handleSearch function effectively 
was called as method of component instance and hence by default 'this' is automatically set to component instance
giving access to this.setState and other component instance properties.

React REF's:
Gives access to a single DOM element.
We create ref's in the constructor, assign them to instance variables in the constructor,
 then pass to a particular JSX element as props.

If you assigned a reference to the ref to an image element which has src an online link, 
then image takes some time to laod isn't it ?

So in componentDidMount, if you logged this.refVariable.current, and you expand the object, you will get all the details,
but you log them, like the height of it directly like, this.refVariable.current.clientHeight, you will get 0.

Weird isn't it ? This is because when you log the dom object via ref reference, and expand it, chrome at that instance will pull
out the DOM element and shows its details.
But when you log out directly the dom element's height it will show as 0, becuase at the time when componentDidMount triggered
the dom was indeed mounted, but image was still fetchingfrom the link mentioned in its src attribute, hence the 0 value.
But when you expanded the DOM object, what you get is the instance pulled out at that fresh time after the image has loaded.
Hence you get the current value.

To work around this and to access height image, you can actually addEventListener 'load' to the DOM element and then you can actually
access the height in the call back provided to the listener, becuase by the time load has got completed.

Fetching data via Redux/ Redux-thunk:
Components are generally responsible for calling the data they need by calling action creators. Generally they call these
action creators in componentDidMount.
Action creators are responsible for making API requests., this is where redux-thunk comes into play. It gets the dat from the server,
then dispatches the data to the state
We get fetched data into our application, when redux sees the new state and causes a re-render, mapStateToProps injects the new
 state again.

Why could not we just use redux, why do we use redux-thunk ?
Redux is a simple library that recieves calls from dispatch takin in a param a simple object having a property 'type', 
after which reducers gets run and return new state if the computation results one.
But if you introduce aysnchronous stuff, there could be failures sometimes when interacting with network and that could result
in a nasty set of errors and the poor redux doesn't know how to deal with that alien set. It simply doesn't know, hence No.

So what does redux-thunk do ?
Redux thunk relaxes the rule that return type should be a plain object with a must property 'type'.
So how does it do it ?
Redux-thunk just uses a simple cool trick, its algorithm is like this, 
if the return type of action creator is a function just execute it and optionally return the result, else just return the result 
of action creator. So what happens if its a function, redux-thunk calls it with a dispatch and getstate params.
So if we return an async function that makes a network requests and calls the required action at the end, redux-thunk
calls the function and optionally dispatches an action of plain object with proeprty 'type',
and also optionally return a result but if return a plain object it will be simply returned to dispatch for processing.
So whenever anything is dispatched, redux thunk recieves it before dispatch, if its a function, 
execute it and optionaly return the result. if its plain object then definitely return it as is.

You cannot return 'undefined' value from reducer, it can even return null but not 'undefined'.

While returning values from reducer you should not directly mutate inouts. Its opposed to the principle of Pure functions.
Though reducers recieve global params, it doesn't lose its pure function status. But changing it does!.

You need not worry about numbers or '''strings''', but you have to worry about objects or arrays as they could be mutated!!

Never ever forget to pass a default state value to the reducer while writing it.

The state can be accessed by referring to key which holds the reducer function in combine reducers functions. Whenever an action is 
dispatched, all the reducer functions present in the combine reducers run and assign their return value in the state object
with the same key name as they were declared in combine reducers function.

Memoization function:
This function take input a function and memoizes the params with which its being called.
So once this memoized function is called twice with same arguments, it doesnt do all the computation second time, it just returns 
the return value which it did when it was invoked the first time.

syntax : cosnt newMemoizedFunc = _.memoize(some function() {});
Now newMemoizedFunc remembers all the params with which it is being called and only invokes 'some' function when the params are 
new to it, else it just returns the already computed value which it computed and stored for future reference when it was invoked
for the first time.

When you use memoize thunk functions, you need to remember some basic javascript concepts. Thunk function returns a function
basically. So if you apply memoization on outer function, do you think the computation will not occur again for the same params ?
Think again, we basically return the function inside, memoization function just returns the computed value with the same param
or computes if its a new param and returns the computed value again.
So basicaly no matter what if its same param or new param, it returns the new thunk function and redux will compute all that again.

Do you want to memoize the inner returned function? Unfortuantely the returned function is an anonymous function or a general 
variable of a function without a variable name which gets declared for every function invocation of outer function. Hence memoize
 gets a new function reference again and again hence computes again every time irrespective of the param.

So what to do ?

Don't declare an anonymous function, declare a function outside of thunk function as a module level variable.
So it wont be redeclared every time the function invokes.

There was a problem where in componentDidMount, repeatedly the calls were made to same data, one way was to memoize the functions.
Other way, well first the problem definition,
Get all blog posts, iterate all the posts and filter out unique users, then fetch each post.
This was the problem statement,
One way was to memoize the fetch user so that when a request was made to the same user, memoize just used to return the 
previously fetch value. 
But there is one little problem, memoize only memoizes previous input value.. so it would work, if authors came like 
1,1,1,2,2,2 and so on it would work.
But if they came like 1,2,1,1,2,1, then a request will be made again for user 1 immediately after request is made for 2
even after 1 has been fetched.
To circumvent this problem, one thing would be to fetch all posts and then get all the unique users and fetch each user individually.

Here comes the beautiful usage of async and await.. 
Since you have two seperate action creators for fetchUSers and fetchPosts, and if you write a super functon, which 
fetches posts and then after users, you have to wait for fetchPosts action creator to be completed.

Now since fetchPosts is an async function, we can put await keyword before that and wait till posts are fetched before moving 
onto fetching users.

Now you fetch the users by liquidating getState, and iterate over each userid, bring out the unique collection, and fetch each 
userId.

Now, lets take a look at the code, there are some brilliant things to notice.

// Action creator for fetchPosts, its a thunk actually.
export const fetchPosts = () => {
  console.log("Fetching posts..");
  return async dispatch => {
    const response = await JSONAPI.get("/posts");
    console.log("Response:", response);
    dispatch({ type: "FETCH_POSTS", payload: response.data });
  };
};

// A private fetchUser function, actually it was declared seperately so that to pass to memoized function.
const _fetchuser = _.memoize(async (id, dispatch) => {
  const response = await JSONAPI.get(`users/${id}`);
  dispatch({ type: "FETCH_USER_BY_ID", payload: response.data });
});

// Action creator for fetchUsers.
export const fetchUser = id => {
  return dispatch => _fetchuser(id, dispatch);
};

// The super function, where we want to get posts an asynchronous action and then once it is completed, we would like
// to fetch users.

// Notice the signature, we are using overloaded function that includes getState.
export const fetchPostsAndUsers = () => async (dispatch, getState) => {
  // Now this is the cool thing, we want to call the action creator, it's a 2 layer function and in
  // second layer, it needs to passed dispatch method. So how are we gonna call that in this action creator ?
  // It's much more easy than we think, just call it the way how you call a regular action creator..
  // Generally we call an action creator in a component, passed on by mapDispatchToProps. Here what
  // mapDispatchToProps does is it passes the invoked value of that action creator 
  // as a param to to dispatch call. 
  // mapDispatchToProps(disaptch) { return { actionCreator1: dispatch(actionCreator1())}}
  // Just like below.

  await dispatch(fetchPosts());

  // Now in redux, where redux-thunk middleware is present, whenever a function is received by dispatch call, rather than a plain
  // action object, it invokes it with dispatch param. So action creator fetchPosts invocation returns a function, 
  // so dispatch call on it, gets it invoked with 'dispatch' function as param. And the thunk code for fetching posts runs. 
  // That's a clever technique, if you ask me.
  // The await in before it ensuresd that async function - fetchPosts is complete.
  
  // Here, in the below line, we are calling getState and getting access to posts. Since in the above call, dispatch of
  // returned posts from the server is pushed into redux state( actually this line in fetchPosts:
  // dispatch({ type: "FETCH_USER_BY_ID", payload: response.data }); ), and only then await lets you in on the next statement,
  // the below getState, actually has access to latest state of posts and hence the below line works as expected.
  const userIds = [ ...new Set(getState().posts.map( post => post.userId))];
  console.log(userIds);

  // again the intelligent use of and the basic way on how to call a thunk is employed here, calling another action creator in
  // dispatch call to make it run.
  userIds.forEach( userId => dispatch(fetchUser(userId))) ;
}

Routing in React:
We install React-router-dom package.

Usage:

import { BrowserRouter, Route } from 'react-router-dom';

<BrowserRouter>
  <div>
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

That route gets activated, whose path matches with address in broswer navigation bar.
Rest all components just hide themselves.

Use it like below:

<BrowserRouter>
  <div>
    <Route path="/home" component={Home} />
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

Home component gets displayed twice. Becuase thats the way react router works.

Weirdly enough there is one more gotcha..

<BrowserRouter>
  <div>
    <Route path="/" component={login} />
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

Now here, both the dashboard and login component gets displayed.?
Why you ask, thats becuase every route gets activated with the below logic,
if browser_navigation_address_bar.path.contains(route_path) display_concerned_component.
So, if browser path is "/home", then "/home".contains(), matches both strings "/", "/home".

If you want to do a strict equality check, pass in 'exact' prop to each route component.

Now to navigate, general idea is to use anchor links, but in react, its a very bad idea.
What happens when we click an anchor tag ?
Our browser makes a request for locahost:3000/that_spcific_link
Development server responds with index.html file,
Browser recievesd index.html file, dumps old html file it was showing and along with that all of ypu react/redux data!.
Now broswer downloads the scripts listed in our index.html and our app starts afresh!

To avoid that we can Link component provided by react-router-dom.
Although this displays the plain anchor tag in the final html, the usage of link component wires the anchor tag such that
React router prevents browser making a separate request. URL still changes and the history gets updated. The same index.html
file is used. This is where SPA term comes up!
As a result, BrowserRouter gets updated and communicates the new url to all Route  child components.

So there are also other types of routers like HashRouter and MemoryRouter from react-router-dom package.
HashRouter basically inserts a # sign after TLD, Top Level Domain.
In localhost:3000/page_one, localhost:3000 is TLD.
In BrowserRouter, If we request for page_two, url gets changed from locahost:3000 to localhost:3000/page_two.
In HashRouter, it will be like localhost:3000/#/page_two. 

So why two routers?
Traditional HTML servers, respond with a 404 error, when there is  no resource found under that specific path, so if we are
using tradition html server to serve react-app, we can configure route path in server that it should not look any path
specifics after # sign and that way, HashRouter helps in easy deployment and configuration in Tradtional Server.

There is another router, MemoryRouter for which path never changes.


############################ Review the routing course again please. Also review the twitch app example carefully, once we
click the anchor link and then, Link component doesn't work properly.

Not only that redux devtool makes you jump to a state, it also changes the app state to that phase.
One more thing, if you dont hook up window__devtool object in compose enhancers, then it cannot be seen,
also if you keep it like that, then in prod also, it will be visisble, so be aware.

You can persist the debug session, by putting at the end of the url ?debug_session='some_String_'

Then it if you use that url, again without closing the browser, the same state will be visisble again, even after multiple
refreshes and also more over you can you can actually jump back and forth and see what went wrong!!

Also, if you have to maintain a group of objects in array, and each object has a unique id that uniquely distinguishes them,
then we can actually do an object based reducer.
we first createa a new state by new state = { ...state};
then newState[id] = action's new object.
or in single line return { ...newState, [id]: action.payload};

also,await on an promise expression returns result.
For example , promise.then( data => data.json()), can be written as (await promise).json();











