'React' knows all about component and how to make components work together.
'React-Dom' knows how to take a component and show up it in the DOM.

Create-react-app installs webpack, babel, devserver.
Babel is used to compile versions of javascript that belongs to ES2015  to ES2019 into ES5 version.
ES5 is  supported by almost all browsers.
ES2015 has greater support, but still there are exceptions.
But from ES2016 till ES2019, there is no support yet.
Babel spits out ES5version code.

Babel also converts JSX.

JSX is a simple extension to Javascript that looks like a templating language and allows us to define the UI structure
in the component in familiar HTML syntax.

JSX vs HTML, there are 3 differences that we have to take care while we write JSX.
Although JSX share many similarities with HTML,
1. Style is defined as an object rather than as an attribute, ex: <div style={{backgroundColor: 'red';}}/>
   Also, background-color is how CSS refers it, but in React, how it has changed like backgroundColor, the hyphen is removed and
   letter after that is capitalized. Now if a css property is there like.. border: 1px solid red; => { border: '1px solid red';}
   The values ofcourse would be value JS types belonging to number or string, array can also be used, but it will converted into 
   value equal to its toString representation.
2. JSX used 'className' instead of class unlike HTML to denote a application of a css class. ex: <div className='cool'/>
    and htmlFor for 'for' in case of Label tags.
3. JSX actually can refer variables inside it. Do little bit of Javascript and generate more JSX inside it.
    like if there is a loop inside a JSX that actually returns JSX, that will evaluated.
    ex: { <ul>{ items.map(item => <li>item.value</li>) } </ul>}.
    Here, inside JSX, list of 'li' items will be produced whose count will be equal to items.length.
4. There is very little much of things that JSX can display, a valid JSX will be turned to equivalent HTML and will
   be displayed, and just a string( Array as toString) or number can also be considered as valid JSX that could be displayed.
   If you try to print or display object, it will say its not a valid child of React. OR not a valid React Children.
   Although you can refer any valid JS type. And can actually embed any expression in JSX, 
   the expression will be evalauted and its result will be shown.

Components:
3 Tenets of components:
Component Nesting: A component can be shown inside of another.
Component Reusability: We want to make components that can be easily reused through out our application.
Component Configuration: We should be able to configure a component when it is created.

Miniature Comment app:
So if we build a comment app that generates comments,
Its obviously essentail to build the comment component out of the main component that hosts it, so that there is clear logic 
seperation.
Now we can host the comment app inside APP - container component. This gives two things,
component nesting and component reuse.
We can decalare multiple comment instances inside app component for to all the comments thats we see.

So you declare a comment componet code in separate file, but you need to declare required packages again here.
Like react etc,

Regrading comment configuration, props comes into picture.
Props system is what we use to distinguish one componen system from another.
Becuase obviously every comment has a same structure but different content. Props system is how we send the component specific data.

Here app component hosts comment-detail component.
The parent component is responsible for passing props down to child. Effectively controlling the content of each component
instnace and also so much as to customize the behaviour of each component like behavior of component w.r.t to user interaction etc..

So how do you pass this props ?
There is no magic, while we declare the component that we want in JSX, we also pass some the data we want as key value pairs 
inside the component tag. ex:
<ComponentName key1:"data" key2:{object1.prop1.someData} />

If the component is a functional component, it will recieve a param object conventionally called params,
which has all this key value pairs as object properties.
We can then access it inside the component by just referring the name.
We can pass as props any valid js types including functions.

Not satisfied with the component reuse functionality and componet composition example.
Lets think of a approval card example.
An approval card in a typical blog platform for a comment would be like the one where it asks the blog author to approve a comment
provided by netizens.
Here approval card is just a basic ui card, typially we can wrap the comment component in this approval card and ask them to
approve the componetn and also, we can provide some text i nthe same approval card to confirm some action that they are performing.
See, we used comment component inside a approval card component, component composition and component resuability.
Because we use that comment component to display as well as for as approval as well.
Composing thus provides a way to build component which are sophisticated out of simple components.

Now we have to learn props.children property.
Here we can pass componet as one of key value paors in props, or we can wrap the component in the opening and closing tags 
of the parent component.
like below:
<Parent><children/></Parent>

Now in the parent component, it is available as props.children, pass whatever in the opening and closing tags of a component, it will 
be available as props.children!

So there you go a great example for component reuse and component composition.

A component is anything that generates HTML and reacts to user events and accodingly gives response.

So far, we have seen functional components, lets talk about class components.
A functional component is used to display simple content and a class component is used for anything else.

A class component while allowing you ti give a sense of organized code, it also gives access to state and lifecycle methods
to control component manoeuver through out its birth till death.

To give an example where class component shines: 
Imagine where we are locating a clients location by using geolocation api, then based on its result, we want to display its 
location.

In functional component, JSX is displayed as and when its prepared, how do you display it again after the result from api returns?
If you delay the return call till location api returns results then user is gonna wait.. right ?

Class component allows you to display some content while our api is fetching the lcoation like a spinner and then re-display the 
content once api result comes up!

So this done by with the help of state system:
A state is a traditional JS object taht contains the data relevant to the component instance.
Updating state always re renders the component. ( mostly instantly)
State must always be initialised before usage.
State must always be updated with setState function.

State lifecycle walk through:
Now that we have established the basic rules how are we gonna achive the solution to above problem.

We initialise the state in constructor with lat property as null, in constructor.
And also with the error propety to show the error message if anything goes wrong.

this.state = {lat:null, err: null}.

We make call to geolocationapi in constructor function, we set the lat property in success call back.
We set the error property incase of an error.
Now we refer the latitiude in render function via state.
Initially nothing is displayed, but when the api results are out, if its success, success call back updates the lat property,
this triggering the re-render and hence lat is displayed.
else the error property is displayed.

WE can conditionally render either of this depending on the state value.
This is how we achieve the solution.

Lifecycle methods line by line - by order:
constructor function is called when the component instance is created.
render method is called to display JSX.
componentDidMount is called as soon as the component instance is mounted on the DOM.

Whever the state chanegd or props changed..
render method will be again called.
componentDidUpdate method will be called right after component is mounted on DOM with updated data.

Once when the time comes when component has to be removed from the DOM, then componentWillUnmount will be called.

Its a react recommendation and a genral best practice to put the network calls inside the componentDidUpdate.
Although there will be 2 renders, react will quickly construct the new DOM in no time!

To provide a default params : syntax would be..

component.defaultProps = {
    ... all the props param defaults.
}

Mind it...always when event handler is passed to an event in the form, only reference is passed.
It's basically like the copy of function is being passed and so by default no instance of 'this' will be set.

Also, in controlled components, React owns the data rather than DOM.
Beucase when we display an input field and type some data into it, DOM actually stores the data.
In case of a controlled component, React owns it and without ever digging into DOM, it owns the data flow of App.

Basically in the form field when you press enter on any input, it actually submits the form!!!
remember this, so that you will call event.preventDefault() onSubmit event.
Also, after on sumbit all input fields get reset, so its important to know this.

Always and always remember when you use value props, always include a handler function for onChange or else you are 
essentially displaying a read-only field.

The interesting thing about how event handler functions declared in class do not have access to this.state or this.props 
or for that matter 'this' itself, is it can be fixed by not only binding 'this' to that function in the constructor 
but also by making the event handler an arrow function, but also...

Call the normal event handler function in the context of arrow function, yes that fixes it!

like just (event) => call_to_normal_Event_handler_non_arrow_function(event)
The above expession works and the normal event handler function with this can again have access to this that points to the instance of 
component.

The props system is not only desinged to configure the child components, but also a way to communicate with parents from the 
children side. Generally it is done via callbacks being passed down as props to the child components and the child components
generally call those funcions with the data the child wants to send back to the parent.
Wheever props changes, componetn will rerender, componentDidUpdate gets triggered for sure.

One interesting and very important thing to remember is that, when we send a function as props to some other component,
then it results back with some data by calling that function.
Here in this function, which we sent as props, if we call this.setState, it would not work!!!, reason, the function was 
send as a reference rather than any. Hence the function now which is part of props object,
will have its this property set to the props object and hence no access to this.setState obviously.

So we always bind our event handlers by default in constructor. Now you know the reason.
Also, if event handler is an arror function or while passing to props if its sent in the context of arrow function call
this issue would not arise.
ex: for in context of arrow function: <SearchBar onSubmit={(term) => this.handleSearch(term)} />
The arrow function wraps the this as parent component instance and so in effect, the handleSearch function effectively 
was called as method of component instance and hence by default 'this' is automatically set to component instance
giving access to this.setState and other component instance properties.

React REF's:
Gives access to a single DOM element.
We create ref's in the constructor, assign them to instance variables in the constructor,
 then pass to a particular JSX element as props.

If you assigned a reference to the ref to an image element which has src an online link, 
then image takes some time to laod isn't it ?

So in componentDidMount, if you logged this.refVariable.current, and you expand the object, you will get all the details,
but you log them, like the height of it directly like, this.refVariable.current.clientHeight, you will get 0.

Weird isn't it ? This is because when you log the dom object via ref reference, and expand it, chrome at that instance will pull
out the DOM element and shows its details.
But when you log out directly the dom element's height it will show as 0, becuase at the time when componentDidMount triggered
the dom was indeed mounted, but image was still fetchingfrom the link mentioned in its src attribute, hence the 0 value.
But when you expanded the DOM object, what you get is the instance pulled out at that fresh time after the image has loaded.
Hence you get the current value.

To work around this and to access height image, you can actually addEventListener 'load' to the DOM element and then you can actually
access the height in the call back provided to the listener, becuase by the time load has got completed.

Fetching data via Redux/ Redux-thunk:
Components are generally responsible for calling the data they need by calling action creators. Generally they call these
action creators in componentDidMount.
Action creators are responsible for making API requests., this is where redux-thunk comes into play. It gets the dat from the server,
then dispatches the data to the state
We get fetched data into our application, when redux sees the new state and causes a re-render, mapStateToProps injects the new
 state again.

Why could not we just use redux, why do we use redux-thunk ?
Redux is a simple library that recieves calls from dispatch takin in a param a simple object having a property 'type', 
after which reducers gets run and return new state if the computation results one.
But if you introduce aysnchronous stuff, there could be failures sometimes when interacting with network and that could result
in a nasty set of errors and the poor redux doesn't know how to deal with that alien set. It simply doesn't know, hence No.

So what does redux-thunk do ?
Redux thunk relaxes the rule that return type should be a plain object with a must property 'type'.
So how does it do it ?
Redux-thunk just uses a simple cool trick, its algorithm is like this, 
if the return type of action creator is a function just execute it and optionally return the result, else just return the result 
of action creator. So what happens if its a function, redux-thunk calls it with a dispatch and getstate params.
So if we return an async function that makes a network requests and calls the required action at the end, redux-thunk
calls the function and optionally dispatches an action of plain object with proeprty 'type',
and also optionally return a result but if return a plain object it will be simply returned to dispatch for processing.
So whenever anything is dispatched, redux thunk recieves it before dispatch, if its a function, 
execute it and optionaly return the result. if its plain object then definitely return it as is.

You cannot return 'undefined' value from reducer, it can even return null but not 'undefined'.

While returning values from reducer you should not directly mutate inouts. Its opposed to the principle of Pure functions.
Though reducers recieve global params, it doesn't lose its pure function status. But changing it does!.

You need not worry about numbers or '''strings''', but you have to worry about objects or arrays as they could be mutated!!

Never ever forget to pass a default state value to the reducer while writing it.

The state can be accessed by referring to key which holds the reducer function in combine reducers functions. Whenever an action is 
dispatched, all the reducer functions present in the combine reducers run and assign their return value in the state object
with the same key name as they were declared in combine reducers function.

Memoization function:
This function take input a function and memoizes the params with which its being called.
So once this memoized function is called twice with same arguments, it doesnt do all the computation second time, it just returns 
the return value which it did when it was invoked the first time.

syntax : cosnt newMemoizedFunc = _.memoize(some function() {});
Now newMemoizedFunc remembers all the params with which it is being called and only invokes 'some' function when the params are 
new to it, else it just returns the already computed value which it computed and stored for future reference when it was invoked
for the first time.

When you use memoize thunk functions, you need to remember some basic javascript concepts. Thunk function returns a function
basically. So if you apply memoization on outer function, do you think the computation will not occur again for the same params ?
Think again, we basically return the function inside, memoization function just returns the computed value with the same param
or computes if its a new param and returns the computed value again.
So basicaly no matter what if its same param or new param, it returns the new thunk function and redux will compute all that again.

Do you want to memoize the inner returned function? Unfortuantely the returned function is an anonymous function or a general 
variable of a function without a variable name which gets declared for every function invocation of outer function. Hence memoize
 gets a new function reference again and again hence computes again every time irrespective of the param.

So what to do ?

Don't declare an anonymous function, declare a function outside of thunk function as a module level variable.
So it wont be redeclared every time the function invokes.

There was a problem where in componentDidMount, repeatedly the calls were made to same data, one way was to memoize the functions.
Other way, well first the problem definition,
Get all blog posts, iterate all the posts and filter out unique users, then fetch each post.
This was the problem statement,
One way was to memoize the fetch user so that when a request was made to the same user, memoize just used to return the 
previously fetch value. 
But there is one little problem, memoize only memoizes previous input value.. so it would work, if authors came like 
1,1,1,2,2,2 and so on it would work.
But if they came like 1,2,1,1,2,1, then a request will be made again for user 1 immediately after request is made for 2
even after 1 has been fetched.
To circumvent this problem, one thing would be to fetch all posts and then get all the unique users and fetch each user individually.

Here comes the beautiful usage of async and await.. 
Since you have two seperate action creators for fetchUSers and fetchPosts, and if you write a super functon, which 
fetches posts and then after users, you have to wait for fetchPosts action creator to be completed.

Now since fetchPosts is an async function, we can put await keyword before that and wait till posts are fetched before moving 
onto fetching users.

Now you fetch the users by liquidating getState, and iterate over each userid, bring out the unique collection, and fetch each 
userId.

Now, lets take a look at the code, there are some brilliant things to notice.

// Action creator for fetchPosts, its a thunk actually.
export const fetchPosts = () => {
  console.log("Fetching posts..");
  return async dispatch => {
    const response = await JSONAPI.get("/posts");
    console.log("Response:", response);
    dispatch({ type: "FETCH_POSTS", payload: response.data });
  };
};

// A private fetchUser function, actually it was declared seperately so that to pass to memoized function.
const _fetchuser = _.memoize(async (id, dispatch) => {
  const response = await JSONAPI.get(`users/${id}`);
  dispatch({ type: "FETCH_USER_BY_ID", payload: response.data });
});

// Action creator for fetchUsers.
export const fetchUser = id => {
  return dispatch => _fetchuser(id, dispatch);
};

// The super function, where we want to get posts an asynchronous action and then once it is completed, we would like
// to fetch users.

// Notice the signature, we are using overloaded function that includes getState.
export const fetchPostsAndUsers = () => async (dispatch, getState) => {
  // Now this is the cool thing, we want to call the action creator, it's a 2 layer function and in
  // second layer, it needs to passed dispatch method. So how are we gonna call that in this action creator ?
  // It's much more easy than we think, just call it the way how you call a regular action creator..
  // Generally we call an action creator in a component, passed on by mapDispatchToProps. Here what
  // mapDispatchToProps does is it passes the invoked value of that action creator 
  // as a param to to dispatch call. 
  // mapDispatchToProps(disaptch) { return { actionCreator1: dispatch(actionCreator1())}}
  // Just like below.

  await dispatch(fetchPosts());

  // Now in redux, where redux-thunk middleware is present, whenever a function is received by dispatch call, rather than a plain
  // action object, it invokes it with dispatch param. So action creator fetchPosts invocation returns a function, 
  // so dispatch call on it, gets it invoked with 'dispatch' function as param. And the thunk code for fetching posts runs. 
  // That's a clever technique, if you ask me.
  // The await in before it ensuresd that async function - fetchPosts is complete.
  
  // Here, in the below line, we are calling getState and getting access to posts. Since in the above call, dispatch of
  // returned posts from the server is pushed into redux state( actually this line in fetchPosts:
  // dispatch({ type: "FETCH_USER_BY_ID", payload: response.data }); ), and only then await lets you in on the next statement,
  // the below getState, actually has access to latest state of posts and hence the below line works as expected.
  const userIds = [ ...new Set(getState().posts.map( post => post.userId))];
  console.log(userIds);

  // again the intelligent use of and the basic way on how to call a thunk is employed here, calling another action creator in
  // dispatch call to make it run.
  userIds.forEach( userId => dispatch(fetchUser(userId))) ;
}

Routing in React:
We install React-router-dom package.

Usage:

import { BrowserRouter, Route } from 'react-router-dom';

<BrowserRouter>
  <div>
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

That route gets activated, whose path matches with address in broswer navigation bar.
Rest all components just hide themselves.

Use it like below:

<BrowserRouter>
  <div>
    <Route path="/home" component={Home} />
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

Home component gets displayed twice. Becuase thats the way react router works.

Weirdly enough there is one more gotcha..

<BrowserRouter>
  <div>
    <Route path="/" component={login} />
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
  </div>
</BrowserRouter>

Now here, both the dashboard and login component gets displayed.?
Why you ask, thats becuase every route gets activated with the below logic,
if browser_navigation_address_bar.path.contains(route_path) display_concerned_component.
So, if browser path is "/home", then "/home".contains(), matches both strings "/", "/home".

If you want to do a strict equality check, pass in 'exact' prop to each route component.

Now to navigate, general idea is to use anchor links, but in react, its a very bad idea.
What happens when we click an anchor tag ?
Our browser makes a request for locahost:3000/that_spcific_link
Development server responds with index.html file,
Browser recievesd index.html file, dumps old html file it was showing and along with that all of ypu react/redux data!.
Now broswer downloads the scripts listed in our index.html and our app starts afresh!

To avoid that we can Link component provided by react-router-dom.
Although this displays the plain anchor tag in the final html, the usage of link component wires the anchor tag such that
React router prevents browser making a separate request. URL still changes and the history gets updated. The same index.html
file is used. This is where SPA term comes up!
As a result, BrowserRouter gets updated and communicates the new url to all Route  child components.

So there are also other types of routers like HashRouter and MemoryRouter from react-router-dom package.
HashRouter basically inserts a # sign after TLD, Top Level Domain.
In localhost:3000/page_one, localhost:3000 is TLD.
In BrowserRouter, If we request for page_two, url gets changed from locahost:3000 to localhost:3000/page_two.
In HashRouter, it will be like localhost:3000/#/page_two. 

So why two routers?
Traditional HTML servers, respond with a 404 error, when there is  no resource found under that specific path, so if we are
using tradition html server to serve react-app, we can configure route path in server that it should not look any path
specifics after # sign and that way, HashRouter helps in easy deployment and configuration in Tradtional Server.

There is another router, MemoryRouter for which path never changes.


############################ Review the routing course again please. Also review the twitch app example carefully, once we
click the anchor link and then, Link component doesn't work properly.

Not only that redux devtool makes you jump to a state, it also changes the app state to that phase.
One more thing, if you dont hook up window__devtool object in compose enhancers, then it cannot be seen,
also if you keep it like that, then in prod also, it will be visisble, so be aware.

You can persist the debug session, by putting at the end of the url ?debug_session='some_String_'

Then it if you use that url, again without closing the browser, the same state will be visisble again, even after multiple
refreshes and also more over you can you can actually jump back and forth and see what went wrong!!

Also, if you have to maintain a group of objects in array, and each object has a unique id that uniquely distinguishes them,
then we can actually do an object based reducer.
we first createa a new state by new state = { ...state};
then newState[id] = action's new object.
or in single line return { ...newState, [id]: action.payload};

also,await on an promise expression returns result.
For example , promise.then( data => data.json()), can be written as (await promise).json();


We all know how to make a url dynamic.
We introduce a wildcard or as we programmers love to call it a variable in url and any value that is there will be dynamically
stored under that variable name.

For ex: we declare a route <Route to="streams/edit/:id" ....
Here id is the wildcard/dynamic variable introduced into that route, so when we visit or make a link,
streams/edit/3, we will go to the component designated by that route and we can access that value of the variable from the props
of that component under the path 'match.params.<wildcard/variable_name>
so if variable name is id, then we will get the value in match.params.id
We are not limited to one wildcard, we can introduce as many as we want to.

For example, we have route like this <Route to="streams/edit/:id/:preference" component={EditComponent} />
Then we go to the url streams/edit/3/spicy , then the component EditComponent gets displayed and we get this object in
match.param -> { id: '3', preference: 'spicy'}

Difference between a patch and put request is very important according to rest conventions.
A patch request is meant to update some proeprties. It is essentially merged with the existing object.
A put request simply replaces the existing object with the incoming object coming from the put request.

Why we use react portals, generally we know that our components some times gets deeply nested.
If you remember the stacking context, a z-index of a child element will never surpass the z-index of the parent.
So if the z-index of the parent is much lesser than the z-index of modal, the modal gets that value of its parent element.
In the same case if we try to change the z-index of the parent to achieve the modal functionality in a deeply nested
component, we might be taking a risk where we are breaking the layout of whole app or atleast the dynamics between parent 
element and its direct siblings.

This is where react portals come handy.

The cool thing about arrow funcions is that they can refer to the this of of whatever parent lexical context they are in,
even when nested deep inside of some functions.

When to use history.push('some_path') and <Link to='some_path' .../>
When you want to route on click of something use Link, else if you want to programatically route on some other programmatic 
event other than click, or in response to some calculation or for whatever reason, use history.push

Onething that can catch you off gaurd is using routes without switch, 
so when you do not use switch, you will see that streams/new and streams/:id match and both will be displayed.
Streange right, that is because :id matches everything, even some string like 'new'.
Because it is a placeholder for some value and there are no restrictions on what type of value that it is reserving its place for.

Context is passing props to deeply nested component from parent component without explictly passing that to all the 
components present between child and parent.

Context object is like an invisible pipe that runs among all branches of nested components under the parent component.
You either create a default valued - context object or a provider object of context, to get data flowing into this context pipeline.

You can basically access the data present in this context pipeline in any nested component, by referring to this.context
or creating a consumer component.

The exact syntax is as follows:
create a separate file for a specific context.

import React from 'react';

now create context and return it with a default value.
export default React.createContext('cool');

Now if you want access that value, go to any component and if its a classic component,
then do the below.

import LanguageContext from '../contexts/LanguageContext';

class Some extends React.Component {
  static contextType = LanguageContext;

  Now you can access the value by refering to context property of this class instance.

  like in any of this class method you can refer to this.context and you will get 'cool' value.


Now if you want this value to be changing rather than a fixed value,
you can actually wrap the parent component in provider of that context and passing the value to 'value' prop, so 
whenever the value prop changes in there, it gets reflected in the child component wherever it is accessing.

ex:
<LanguageContext.Provider value={this.state.language}>
  <UserCreate />
</LanguageContext.Provider>

Now if you repeated the code above twice, the user create in each wrapping will have a total independent piepline from the
provider. That is whenever a new instance is created a total independent pipeline is created.

Also, whenever the value is changed the exxisting functions or componetn are called with new props, essentially forcing them to 
re-render to reflect the changed context.

There is also another way of accessing the context by LanguageContext.Consumer, by render props pattern.
The first argument is called with value as expected in that renderprops pattern.

Why do you want this? this is needed if there are multiple contexts and you want to use both the context values in the same 
component. This consumer component syntax, lets you refer the context name that you want to use by its name against the
generic name this.context that can only refer to a single context at any time.

Hooks are designed to share logic better across the component.

Testing:

This is under command environment:
react-scripts test --env=jsDOM 

When you do a ReactDOM.render on a div, it will actually insert the full HTML derived from that component.
This can be used to test the html output of the react specifically.

Whenever there is setupTests.js file under the src directory, Jest runs that file before anytime when it tries to execute test files.

Enzyme provides 3 options to test React, 
Static - Render the given component and return plain HTML
Shallow - Render just the given component in HTML and none of its children
Full DOM - Render the given component and all of its children and let us modify the HTML afterwards.

Do you know that form gets submitted when you click on form's submit button, beware of that in react and see that you call
event.preventDefault() in the handler function of that button.
No matter what if there is a button in form, and you click it, it gets submitted automatically.
Beucase button default type is 'submit', to stop this default action, you can also do type='button', but
it doesnot autimatically submit the form ofcourse. there is also one mroe type to button, 'reset'.

Unlike static or shallow redndering, full rendering actually mounts the component in the DOM, which measn taht test can effect 
each other if they are all using the same DOM. So do a unmount call as a cleanup.

Ever wondered how you gonna check the text box value after a re render or any of the input element after a render of for 
that matter during inital render even, in context of react testing.

wrapper.find('textarea').simulate('change', { event: { target: 'cool'}});
wrapper.update();

expect(wrapper.find('textarea').prop('value')).toEqual('new comment');

As we see the value prop is passed to text area, we inspect that prop value and voila we are done testing!
MAke sure you also call wrapper.update(), when your tests tocuh the code path, setState call atleast once.
This way you can be assured that asynchronous call of setState was acted upon.

Syncs the enzyme component tree snapshot with the react component tree. Useful to run before checking the render output 
if something external may be updating the state of the component somewhere.

NOTE: can only be called on a wrapper instance that is also the root instance.

NOTE: this does not force a re-render. Use wrapper.setProps({}) to force a re-render.

Generally we can actually use describe in testing to limit the scope of before each and after each as well.
So if you have 3 tests which require some common functionality you can group them in a describe and write a beforeEach for them.

The connect function generally requires that it is called under hierarchy of provider component.

IF you want to test the html of a componenet, you can do by enzyme by calling the render method of that component, 
it returns a cheerio wrapper of it. Cheerio wrapper is a light weight implementation of jquery syle object.
You can query the hmtl, just the way you do with actual jquery.
That way you can add class remove class, add text, remove text and all etc..

Why does axios request fail in testing environment, the answer is simple, all our components in test suite are mounted on 
JS Dom -- fake browser environment rather than real dom of browser, which can assit in making network requests.
But the JS Dom can do no such help, hence the axios fails in test suite.

We can actually install moxios, tha helps axios get response without actually making a network call.
Why do we test a 3rd party library first of all, during integration testing ofcourse, we wish to return the mocked results
instead of original results to test out different scenarios and also round trip of original network requests also delay tests.

in beforeEach() of our request, we actually, call moxios.install();
then d o a intercept of network request axios is trying to make and return it with the dat we wish to return.

beforeEach(() => {
  moxios.install();
  moxios.stubRequest('url_you_want_to_intercept', {
    status: 200,
    response: <the_response_you_want_to_return>
  })
});

and in afterEach() you do a moxios.uninstall so that it will not interfere with the other axios request the application or another
test suite is attempting to make.

sometime moxios can take time to respond, so if you are actually testing any logic, that has to happen after request gets 
completed, the testing might fail as they are immediately tested without any wait happening.
We can include all that logic of testing in moxios.wait( () => {}); and it will be executed immediately after all pending requests
ae completed from teh moxios side.

Also, since this is an asynchronous request, we have another problem, whenever tehre is an asynchronous logic, jest doest wait for that
statement to get completed, hence it will give us a param, done  and till ti is called, jest doesnt mark the test as completed
and patiently listens for any errors that might happen.
Call teh done function after syour async request is complete or after all the async testing logic is complete, jest will 
continue ending the test.

Cookies vs tokens:
Cookie: 
Automatically gets included on all requests.
Unique to each domain.
Cannot be sent to different domains.

Since HTTP protocol is stateless, to provide context for each request cookies are used. They manifest themselves in the header.
It contains information such as User ID, that server can uniquely recognize and authenticate and authorize him.

Token:
Have to manually wire up.
Can be sent to any domain.

So if cookies somehow fill the purpose, why we are actually going to the tokens, now a days websites are being hosted on content
server, which just serve index.html and bundle.js.
So content servers are cheap, leight weight can spit that index.html + bundle.js to any different location in the world easily,
and can handle any nmber of requests. But API server nned not be in the same server or domain. See Web server and native app
can make api calls to the same server and it can very well be in different domain. Makin API server as a discrete, independent
entity has its own advantages. So tokens now help you in making requests to different domains securely.

More over, mobile trafiic may be more than web traffic, and now the api server may be sitting behind the load balancers to 
balance out the traffic, and we also do not want to have a down time for server, when we are pushing updates to the website.
So to have a much granular control, they may very well be in different domains and tokens are an easy way to authenticate
the users in that case.

As part of authentication we are also gonna discuss some setup from server side, so you are gonna see some node discussion
as part of that as well and hence despite its not react, this is also being discussed.

// Main starting up point of the application

// if you want to import like this in node js, you got to add this line in package.json
// "type": "module"

import express from 'express';
import http from 'http';
import bodyParser from 'body-parser';
import morgan from 'morgan';

// unlike as you'd do in react, you got to mention the file name when you import any non module in node.js
import router from './route.js';

const app = express();

// APP setup
// morgan is a logging library

app.use(morgan('combined'));

// so far we misudnerstood the word parse, according to dictionary parse means
// resolve (a sentence) into its component parts and describe their syntactic roles.
// so when we say bodyparser.json, its not that it will parse json, but whatever that is parsed will be made json and 
// described such, in short, it will be made into json!

app.use(bodyParser.json());

// Here in this file, we will use app.get and app.post, etc. and define all kind of possible comminications to handle and the 
// reponses to be sent.

router(app);

// Server setup
const port = process.env.PORT || 3090;
const server = http.createServer(app);
server.listen(port);
console.log('Server listening on:', port);

// Route.js

const route = app => {
  app.get('/', function (req, res, next) {
    res.send(['cool', 'have', 'fun!']); // you can send json as well, it will be printed as string on browser side.
  });
};

In usermodel,
// On save hook, encrypt password.
UserSchema.pre('save', function(next) {
  // The function is run in the context of correct object that is getting saved.
  const user = this;

  // generate a salt, make 10 iterations to produce.
  bcrypt.genSalt(10, function(err, salt ){
    if(err) next(err);
    // Once salt is produced generate a hash combining plain text and salt .
    bcrypt.hash(user.password, salt, function(err, hashedResult) {
      if(err) next(err);

      // since we are running in the context of about to be saved object, we can retrieve it and modify it,
      // so we assign the hash to it instead of password.
      user.password = hash;
      // call the next middleware/ whatever function to continue on the next process
      next();
    });
  });
});


When the user submits a password next time when logging in, salt is again produced, hash is generated with this submitted
password, and compared to the stored hash. if both hashes match, we send them the JWT, JSON Web Token.

When signing up or signing in, give a token in exchange for an id.
userId + our secret string  = JWT.

When the user makes an authenticated request, they should include their JWT.
JWT + our secret string = userId.

We generate JWT by like this:

import jwt from 'jwt-simple';
import SECRET_KEY from '../config.js'; // a smaple random string, but should never be revealed

function tokenForUser(user) {
  const timestamp = new Date().getTime();
  // A jwt is formed from jwt.encode, it will be given 2 params: one object and other SECRET_KEY
  // What object contains is sub(short for subject) which will subject to process of generating 
  // JWT token. You can attach many properties to this object, one such is iat(short for issued at timestamp), this can be used for 
  // to check if the JWT got expired.
  return jwt.encode({sub: user.id, iat: timestamp}, SECRET_KEY);
}

// We send the user JWT token, and he has to store it securely in browser.
// For every authenticated request he has to send this JWT as well.
res.json({token: tokenForUser(user)});

Now how to validate once the user gets us a JWT.
We take the help of passport.js library.
Why ? Passport is an ecosystem rather than a library. Its an ecosystem of strategies. A strategy is one way to authenticate a 
resource. For example authenticating a resoruce via recognizing his JWT. Another strategy could be via handling signing in
via google or facebook. Anotehr strategy could be via logging in with username and password.

So passport can handle all these and many more strategies.

Now whenever we want to employ the strategy for login or any particular route, we have to get that particular strategy from 
now configured passport library.
Here below we are getting jwt strategy authentication.
const requireAuth = passport.authenticate('jwt', { session: false });

app.get('/', requireAuth, (req, res) => {
    res.send('Hi there!');
  });

For any app.METHOD callback you can pass series of callbacks or middlewares, whenever you want to skip the next middlewares
, you can call next(), or invoke any other route handler by calling next('route'). That way, the handler associated with that 
route will be invoked.

if you want to call next, you should also get that as a parameter:
like (req, res, next) => {}. Also you can also pass error object to next to cancel all callbacks inline and throw the error.

Above, in requireAuth, if it has a valid toeken, next middleware will be called, taken care by passport, else requireAuth will 
return string 'Unauthorized'.

You can also use passport to compare the username and password stored in your localdb or somewhere in local.

import LocalStrategy from 'passport-local';

In router :
app.post('/signIn', requireSignIn, signIn);

const LocalOptions = { usernameField: 'email' };
const localLogin = new LocalStrategy(LocalOptions, (email, password, done) => {
  User.findOne({email}, (err, user) => {
    if(err) 
      return done(err);

    if(!user) 
      return done(null, false);
    // How you get this method, you can actually define this in mongoose schema as the follwing function below.
    user.comparePasswords(password, function(err, isMatch) {
      if(err) return done(err);

      if(!isMatch) return done(null, false);

      return done(null, user);
    });
  });
});

// This is the syntax for defining a hook method you can call agaisnt each data object that you retrieved using mongoose.
UserSchema.methods.comparePassword = function( candidatePassword, callback ) {
  bcrypt.compare( candidatePassword, this.password, (error, isMatch) => {
    if(error) return callback(error);

    callback(null, isMatch);
  });
};


To understand nodejs better, always remember that middlewares or callback always pass the error parameter first.
Second would be the data object. You should always define your callbacks in the same manner to maitnain the consistency.

And also remember that the object that we expose via import is same across everywhere. It's the same copy all across the application.

Now that passport authenticated, how do we pass that user information to next middleware?
Luckily and gracefully, passport.authenticate via local middleware, when everything is successful,
we call tis done method by 

res.send({ token: tokenForUser(req.user)});

strange how import modules work in nodejs, either cjs or import syntax.

passport once we set stratgey will work either in two ways:

import passport from 'passport';
import passportService from './services/passport.js';

const requireAuth = passport.authenticate('jwt', { session: false });
const requireSignIn = passport.authenticate('local', { session: false});

we don't use any passportService module declared above in the file, but that some how makes passport.authenticate
knwo the strategies set in services/passport.js file.

It will also work if you declare like this:
import passport from './services/passport.js'.

So what is this thing.. although same passport object is exported in both the files ?
It is becuase if services file is never imported, it will never be called or executed and never setting the strategies required by
passport. So if it was never set, passport object imported will have no strategies set.
But if it was called, all the required strategies are set and by the time you load the module passport here
all the stratgies are already present in that passport object. So the imports placement is crucial, see that all the required 
modules are loaded before you execute your app.

Remember, whenever you wanted to do redirect to the home page after a successful action complete like fetching a resource 
in action creator, you dont have access to history object so you explicily passed a history object to the plain router
and then imported in teh actions file or as an extra parameter history object to the action creator 
or you could also pass a callback and the callback can actually handle this redirect request in component object itself.



















